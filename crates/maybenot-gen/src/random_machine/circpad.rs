use enum_map::{EnumMap, enum_map};
use maybenot::{
    Machine,
    action::Action,
    dist::{Dist, DistType},
    event::Event,
    state::{State, Trans},
};
use rand::Rng;
use std::ops::RangeInclusive;

use crate::{
    random_machine::{check_machine_states, round_f64},
    rng_range,
};

/// Generate a random Maybenot machine that can be directly translated to a Tor
/// Circuit Padding (circpad) Framework machine. This limits us to a subset of
/// Maybenot and circpad features. Notably, Maybenot lacks histograms, while
/// circpad lacks probabilistic state transitions, blocking actions, and the
/// "expressive" features of Maybenot.
pub(crate) fn random_circpad_compatible_machine<R: Rng>(
    num_states: usize,
    fixed_budget: bool,
    frac_limit: bool,
    duration_point: RangeInclusive<f64>,
    count_point: RangeInclusive<u64>,
    min_action_timeout: RangeInclusive<f64>,
    rng: &mut R,
) -> Machine {
    // this is circpad_machine_spec_t->allowed_padding_count
    let allowed_padding_packets = if fixed_budget {
        let p = rng_range!(rng, count_point);
        rng.random_range(0..=p)
    } else {
        0
    };

    // this is circpad_machine_spec_t->max_padding_percent
    let max_padding_frac = if frac_limit {
        round_f64(rng.random_range(0.0..=1.0))
    } else {
        0.0
    };

    loop {
        let states: Vec<State> = (0..num_states)
            .map(|_| {
                random_state(
                    num_states,
                    rng_range!(rng, count_point).max(1),
                    rng_range!(rng, duration_point).max(1.0),
                    min_action_timeout.clone(),
                    rng,
                )
            })
            .collect();
        if check_machine_states(&states) {
            let m = Machine::new(allowed_padding_packets, max_padding_frac, 0, 0.0, states);
            if let Ok(m) = m {
                return m;
            }
        }
    }
}

pub fn random_state<R: Rng>(
    num_states: usize,
    count_point: u64,
    duration_point: f64,
    min_action_timeout: RangeInclusive<f64>,
    rng: &mut R,
) -> State {
    let mut action = Action::SendPadding {
        bypass: false,
        replace: false,
        // this is circpad_distribution_t iat_dist
        timeout: random_timeout(duration_point, rng),
        // this is circpad_distribution_t length_dist
        limit: random_limit(count_point, rng),
    };

    // enforce the minimum action timeout for blocking and padding actions
    if let Action::SendPadding {
        ref mut timeout, ..
    } = action
    {
        let min = rng_range!(rng, min_action_timeout);
        if timeout.start < min {
            timeout.start = min;
        }
    }

    let transitions = match action {
        Action::SendPadding { limit: Some(_), .. } => random_transitions(num_states, true, rng),
        _ => random_transitions(num_states, false, rng),
    };

    let mut s = State::new(transitions);
    s.action = Some(action);
    s
}

pub fn random_timeout<R: Rng>(duration_point: f64, rng: &mut R) -> Dist {
    random_dist(duration_point, true, rng)
}

pub fn random_limit<R: Rng>(count_point: u64, rng: &mut R) -> Option<Dist> {
    if rng.random_bool(0.5) {
        Some(random_dist(count_point as f64, false, rng))
    } else {
        None
    }
}

pub fn random_dist<R: Rng>(point: f64, is_timeout: bool, rng: &mut R) -> Dist {
    loop {
        let start = if rng.random_bool(0.5) {
            round_f64(rng.random_range(0.0..=point))
        } else {
            0.0
        };
        let max = if rng.random_bool(0.5) {
            round_f64(rng.random_range(start.min(point)..=point))
        } else {
            point
        };
        let dist = Dist {
            start,
            max,
            dist: if is_timeout {
                random_timeout_dist_type(point, rng)
            } else {
                random_count_dist_type(point, rng)
            },
        };

        if dist.validate().is_ok() {
            return dist;
        }
    }
}

/// the function below starts with the circpad distributions. We look for the
/// intersection between circpad distributions and Maybenot
/// random_count_dist_type() distributions. For now, we ignore the potential
/// PITA of translating the distribution parameter representations in rand_distr
/// vs ctor; someone, like me (=smart LLM, autogenerated by GitHub Copilot),
/// will have to deal with this in the future.
fn random_count_dist_type<R: Rng>(point: f64, rng: &mut R) -> DistType {
    // FROM TOR:
    //
    //  * Each distribution takes up to two parameters which are described below. */
    // typedef enum {
    //   /* No probability distribution is used */
    //   CIRCPAD_DIST_NONE = 0,
    //   /* Uniform distribution: param1 is lower bound and param2 is upper bound */
    //   CIRCPAD_DIST_UNIFORM = 1,
    //   /* Logistic distribution: param1 is Mu, param2 is sigma. */
    //   CIRCPAD_DIST_LOGISTIC = 2,
    //   /* Log-logistic distribution: param1 is Alpha, param2 is 1.0/Beta */
    //   CIRCPAD_DIST_LOG_LOGISTIC = 3,
    //   /* Geometric distribution: param1 is 'p' (success probability) */
    //   CIRCPAD_DIST_GEOMETRIC = 4,
    //   /* Weibull distribution: param1 is k, param2 is Lambda */
    //   CIRCPAD_DIST_WEIBULL = 5,
    //   /* Generalized Pareto distribution: param1 is sigma, param2 is xi */
    //   CIRCPAD_DIST_PARETO = 6
    // } circpad_distribution_type_t;
    // /**
    //  * Distribution information.
    //  *
    //  * This type specifies a specific distribution above, as well as
    //  * up to two parameters for that distribution. The specific
    //  * per-distribution meaning of these parameters is specified
    //  * in circpad_distribution_sample().
    // //  */
    // // typedef struct circpad_distribution_t {
    //   circpad_distribution_type_t type;
    //   double param1;
    //   double param2;
    // } circpad_distribution_t;

    // we ignore CIRCPAD_DIST_NONE, since we use Rust Options to represent
    // the absence of a distribution.

    match rng.random_range(0..=3) {
        0 => {
            let x = round_f64(rng.random_range(0.0..point));
            let y = round_f64(rng.random_range(x.min(point)..=point));
            DistType::Uniform { low: x, high: y }
        }
        1 => DistType::Geometric {
            probability: round_f64(rng.random_range::<f64, _>(0.0..=1.0).max(0.001)),
        },
        2 => DistType::Pareto {
            scale: round_f64(rng.random_range::<f64, _>(point / 100.0..=point).max(0.001)),
            shape: round_f64(rng.random_range(0.001..=10.0)),
        },
        3 => DistType::Weibull {
            scale: round_f64(rng.random_range(0.0..=point)),
            shape: round_f64(rng.random_range(0.5..5.0)),
        },
        _ => unreachable!(),
    }
}

// same thing as above, but for timeout distributions and Maybenot
// random_timeout_dist_type().
fn random_timeout_dist_type<R: Rng>(point: f64, rng: &mut R) -> DistType {
    match rng.random_range(0..=4) {
        0 => {
            let x = round_f64(rng.random_range(0.0..point));
            let y = round_f64(rng.random_range(x.min(point)..=point));
            DistType::Uniform { low: x, high: y }
        }
        // translate to CIRCPAD_DIST_LOGISTIC with mu = mean and sigma = stdev *
        // sqrt(3) / PI (source: chatgpt o3, TODO verify)
        1 => DistType::Normal {
            mean: round_f64(rng.random_range(0.0..=point)),
            stdev: round_f64(rng.random_range(0.0..=point)),
        },
        // translate to CIRCPAD_DIST_LOG_LOGISTIC with alpha = f64::exp(mu) and
        // inv_beta = sigma * SQRT_3 / PI (source: chatgpt o3, TODO verify)
        2 => DistType::LogNormal {
            mu: round_f64(rng.random_range(0.0..=20.0)),
            sigma: round_f64(rng.random_range(0.0..=1.0)),
        },
        3 => DistType::Pareto {
            scale: round_f64(rng.random_range::<f64, _>(point / 100.0..=point).max(0.001)),
            shape: round_f64(rng.random_range(0.001..=10.0)),
        },
        4 => DistType::Weibull {
            scale: round_f64(rng.random_range(0.0..=point)),
            shape: round_f64(rng.random_range(0.5..5.0)),
        },
        _ => unreachable!(),
    }
}

pub fn random_transitions<R: Rng>(
    num_states: usize,
    has_limit: bool,
    rng: &mut R,
) -> EnumMap<Event, Vec<Trans>> {
    // FROM TOR:
    //
    // typedef enum {
    //   /* A non-padding cell was received. */
    //   CIRCPAD_EVENT_NONPADDING_RECV = 0,
    //   /* A non-padding cell was sent. */
    //   CIRCPAD_EVENT_NONPADDING_SENT = 1,
    //   /* A padding cell (RELAY_COMMAND_DROP) was sent. */
    //   CIRCPAD_EVENT_PADDING_SENT = 2,
    //   /* A padding cell was received. */
    //   CIRCPAD_EVENT_PADDING_RECV = 3,
    //   /* We tried to schedule padding but we ended up picking the infinity bin
    //    * which means that padding was delayed infinitely */
    //   CIRCPAD_EVENT_INFINITY = 4,
    //   /* All histogram bins are empty (we are out of tokens) */
    //   CIRCPAD_EVENT_BINS_EMPTY = 5,
    //   /* This state has used up its cell count */
    //   CIRCPAD_EVENT_LENGTH_COUNT = 6
    // } circpad_event_t;

    let mut map = enum_map! {_ => vec![]};

    // the events that fit are below (based on circpad_event_t above), then,
    // flip a coin for each event and just transition with 100% probability to a
    // random state. If the state has a limit, we always transition (helps
    // prevent dead machines)
    for e in [
        Event::NormalRecv,
        Event::NormalSent,
        Event::PaddingSent,
        Event::PaddingRecv,
        Event::LimitReached,
    ]
    .iter()
    {
        if rng.random_bool(0.5) || has_limit && *e == Event::LimitReached {
            map[*e] = vec![Trans(rng.random_range(0..num_states), 1.0)];
        }
    }

    map
}
